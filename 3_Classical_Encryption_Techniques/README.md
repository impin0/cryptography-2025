# Classical Encryption Techniques

#### Contents:
- Symmetric Cipher Model
- Substitution Techniques
- Transposition Techniques

### Symmetric Cipher Model

**Which key terms do we need to know to talk about cryptography?**  
- *Plaintext*: is the original message
- *Chiphertext*: is the coded message
- *Encryption*: is the process of converting from plaintext into ciphertext
- *Decryption*: is the process of converting from ciphertext to plaintext
- *Cipher / Cryptographic system*: is a certain scheme used for encryption
- *Cryptoanalysis*: techniques used for deciphering a message without any knowledge of the enciphering

**How symmetric cipher models works?**  
Symmetric encryption (or single key encryption) has five ingredients:
- Plaintext: the input data fed into the algorithm
- *Encryption algorithm*: is the algorithm that performs various substitutions and transformations on the plaintext
- *Secret key*: which is also input to the encryption algorithm, it is independent of the plaintext and from the algorithm. The exact substitutions and transformation performed depend on the key
- Cyphertext: the scrambled message produced as output
- *Decryption algorithm*: which is the E.A run in reverse

**Describe the main requirements for the secure use of symmetric encryption:**  
1. A strong encryption algorithm, at minimum the opponent should be unable to decrypt ciphertext or discover the key even if he is in possession of a number of ciphertexts together with the plaintext that produced each ciphertext.
2. Sender and receiver must have obtained copies of the secret key in a secure way and must keep the key secure

**What are the two basic functions used in encryption algorithms?**  
All encryption algorithms are based on two general functions:
- *substitution*, in which each element in the plaintext is mapped into another element
- *transposition*, in which elements in the plaintext are rearranged
With the fundamental requirement is that no information be lost

**Differentiate between secret-key encryption and public-key encryption?**  
The number of keys used:
- If sender and receiver use the *same key* the system is symmetric or single key encryption.
- If sender and receiver use *different keys* the system is referred to as asymmetric, two-key or public key encryption

**What is the difference between a block cipher and a stream cipher?**  
- A block cipher process the input one *block* of elements at a time, producing an output block for each input block
- A stream cipher processes the input elements *continuously*, producing one output elements at a time

**What are the two general approaches to attacking a cipher?**  
- *Cryptanalysis*: this attack exploits the characteristics of the algorithm + knowledge of the general characteristics of the plaintext to attempt to deduce the key or a specific ciphertext
- *Brute-force*: the attacker tries every possible key on one piece of ciphertext, on average half of all the possible keys must be tried to achieve success. To supplement the brute-force approach, some degree of knowledge about the expected plaintext is needed, and some means of automatically distinguishing plaintext from garble is also needed.

**List and briefly define types of cryptanalytic attacks based on what is known to the attacker:**  
- *Ciphertext Only*: known to Cryptanalyst are the encryption algorithm and the ciphertext
- *Known Plaintext*: known to Cryptanalyst are the Encryption algorithm, the ciphertext and one or more plaintext–ciphertext pairs
- *Chosen Plaintext* known to Cryptanalyst are the Encryption algorithm the ciphertext and the plaintext message chosen by cryptanalyst, together with its corresponding  generated ciphertext
- *Chosen Ciphertext* known to Cryptanalyst are the Encryption algorithm, the ciphertext and the ciphertext chosen by cryptanalyst, together with its corresponding decrypted plaintext generated with the secret key
- *Chosen Text* known to Cryptanalyst are the Encryption algorithm, the Ciphertext, the Plaintext message chosen by cryptanalyst, together with its corresponding ­ciphertext generated with the secret key and the Ciphertext chosen by cryptanalyst, together with its corresponding decrypted plaintext generated with the secret key

**Briefly describe the criteria that define a computationally secure cipher:**  
An encryption scheme is *unconditionally secure* if the ciphertext generated by the scheme does not contain enough information to determine uniquely the corresponding plaintext, no matter how much ciphertext is available. With the exception of the *one-time-pad* there is no E.A that is unconditionally secure.
But we can say that an E.A is *computational secure* if the E.A that meets at least one of the following criteria:
- The *cost* of breaking the cipher exceeds the value of the encrypted information
- The *time* required to break the cipher exceeds the useful lifetime of the information

### Substitution Techniques

**How the Caesar cipher works?**  
The Caesar cipher was the first *substitution cipher*, and involves replacing each letter of the alphabet with the letter standing three places further down the alphabet
```
a b c d e f ....... x  y  z
0 1 2 3 4 5 ....... 23 24 25
C = E(3, p) = (p + 3)mod26
C = E(k, p) = (p + k)mod26    0 <= k <= 25
p = D(k, C) = (C - k)mod26
```

**Why is the Caesar cipher substitution techniques vulnerable to a brute-force cryptanalysis?**  
It is vulnerable to brute-force attacks because:
- The encryption and decryption algorithms are known
- The space of the possible keys is very small (only 26\* possible keys) 
- The language of the plaintext is known and easily recognizable

**How much key space is available when a monoalphabetic substitution cipher is used to replace plaintext with cyphertext?**  
A permutation of a finite set of elements S is an ordered sequence of all the elements of S, in general there are n! permutation of a set of n elements, using the alphabet (26 letters) -> the possible keys are 26! = 4 x 10^26  
But monoalphabetic cipher are easy to break because they reflect the frequency data of the original alphabet -> *frequency analysis attacks* of single letters, diagrams and sequence of more letters

**How can we decrease the efficiency of frequency analysis attacks?**  
To lessen the extent to which the structure of the plaintext survives in the ciphertext we can: encrypt multiple letters of plaintext or use multiple cipher alphabets, one of the first cipher to do that was the Playfair cipher

**What is the drawback of Playfair cipher?**  
The Playfair cipher is a *multiple letters encryption* (poligraphic) cipher which treats digrams in the plaintext as a single units and translate these units into ciphertext diagrams.
The Playfair algorithm is based on the use of a 5 x 5 matrix of letters constructed using a keyword
``` 
Keyword = monarchy
M   O   N   A   R
C   H   Y   B   D
E   F   G   I/J K
L   P   Q   S   T 
U   V   W   X   Z
```
The plaintext is encrypted two letters at a time with the following rules:
1. Repeating plaintext letters that are in the same pair are separated with a filler letter such x. -> balloon = ba lx lo on
2. Two plaintext letters that fall in the same row of the matrix are each replaced by the letter to the right, with the first element of the row circularly following the last. For example, AR is encrypted as RM.
3. Two plaintext letters that fall in the same column are each replaced by the letter beneath, with the top element of the column circularly following the last. For example, MU is encrypted as CM.
4. Otherwise, each plaintext letter in a pair is replaced by the letter that lies in its own row and the column occupied by the other plaintext letter. Thus, hs becomes BP and ea becomes IM (or JM, as the encipherer wishes)

It is a great advance over simple monoalphabetic ciphers, whereas there are only 26 letters there are 26 x 26 = 676 digrams -> the identification of individual digrams is more difficult.
But remain easy to break because it still leaves much of the structure of the plaintext language intact

**How the hill cipher works?**  
It is a monoalphabetic poligraphic cipher (every m letters are encrypted in the same way) that takes m successive plaintext letters and substitutes for them m ciphertext letters. The substitution is determined by m linear equations in which each character is assigned a numerical value
```
m = 3
c1 = (k1,1p1 + k2,1p2 + k3,1p3)mod26
c2 = (k1,2p1 + k2,2p2 + k3,2p3)mod26
c3 = (k1,1p1 + k2,3p2 + k3,3p3)mod26
                  = 
(c1)   (k11 k12 k13)     (p1)  
(c2) = (k12 k22 k23)  *  (p2)  mod26
(c3)   (k31 k32 k33)     (p3)  
                           
Plaintext = paymoremoney
p = 15, a = 0, y = 24,  
m = 12, o = 14, r = 17,  
e = 4, m = 12, o = 14,  
n = 13,e = 4, y = 24

The matrix must be invertible to decrypt the ciphertext!
      (17, 17, 5)
key = (21, 18, 21)
      (2, 2, 19) 

c1 = (17 * 15 + 17 * 0 + 5 * 24) mod26 = 11
c2 = (21 * 15 + 18 * 0 + 21 * 24) mod26 = 13
c3 = (2 * 15 + 2 * 0 + 19 * 24) mod26 = 18

11 = L, 13 = N, 18 = S

The block PAY is chifer into LNS
```
the strength of the Hill cipher is that it completely hides single-letter frequencies. But it is easily broken with a known plaintext attack.

**What is the difference between a monoalphabetic cipher and a polyalphabetic cipher?**  
Monoalphabetic ciphers uses just one monoalphabetic substitution
Polyalphabetic ciphers uses *different monoalphabetic substitutions* as one proceeds through the plaintext message, they all have the following features:
1. A set of related monoalphabetic substitution rules
2. A key determines which particular rule is chosen for a given transformation

**How can an attack determine the length of the keyword used in the Vigenère cipher?**  
The Vigenére cipher is the simplest polyalphabetic substitution cipher where the set of related monoalphabetic substitution rules consist of the 26 Caesar cipher with shifts of 0 through 25 each cipher is denoted by a key letter which is the ciphertext letter that substitutes for the plaintext letter a
Plaintext: P = p0, p1, p2 ... pn-1
Key: K = k0, k1, ...., km-1   (typically m < n)
Ciphertext: C = c0, c1, ... , cn-1              Calculated as follows:
```
C =  c0, c1, ... , cn-1 = E(K, P) = E\[ (k0, k1, ... , km-1), (p0, p1, ... , pn-1)] = \[(p0 + k0)mod26, (p1 + k1)mod26, ... , (pm-1 + km-1)mod26, (pm + k0)mod26, ... , (p2m-1 + km-1)mod26, ...]

Ci = (pi + kimod m)mod 26
```
To break this cipher we can:
1. Determine if they used monoalphabetic substitution or a Vigenère cipher. By usingn the frequency analysis: if the statistical properties of the ciphertext are close as that of the language of the plaintext -> monoalphabetic substitution. Otherwise if Vigenére progress depends on determining the length of the keyword
2. Determine the keyword length: If two identical sequences of plaintext letters occur at a distance that is an integer multiple of the keyword length, they will generate identical ciphertext sequences -> we can create good guesses of the keyword length
3. If keyword length is m, then the cipher consist of m monoalphabetic substitution ciphers, thus we can use frequency characteristics of the plaintext language to attack each of the monoalphabetic ciphers separately

We can eliminate the periodic nature of the keyword using an *autokey system* in which a keyword is concatenated with the plaintext itself to provide a running key but even this scheme is vulnerable to cryptanalysis because the key and the plaintext share the same frequency distribution of letters, a statistical techniques can be applied: e encrypted by e occur with a frequency of (0.127)^2 0.016, t by t half as often etc etc...

**How the one time pad works?**  
It uses a random key that is long as the the message, it produces random output that bears no statistical relationship to the plaintext.
The security of the one-time pad is entirely due to the randomness of the key. If the stream of characters that constitute the key is truly random, then the stream of characters that constitute the ciphertext will be truly random. Thus, there are no patterns or regularities that a cryptanalyst can use to attack the ciphertext.

**What are the problems of one time pad?**  
1. We have a practical problem of making *large quantities of random keys*, supplying truly random characters in this volume is a significant task
2. *Key distribution and protection* For every message to be sent, a key of equal length is needed by both sender and receiver.

### Transposition Cipher
**What is a transposition cipher?**  
The mapping is achieved by performing some sort of permutation on the plaintext letters  
The simplest is the *rail fence* where the plaintext is written down as a sequence of diagonals and then read off as a sequence of rows  
A more complex scheme is to write the message in a *rectangle* row by row, and read the message column by column but permute the order of the columns (which is the key of the algorithm)  
A pure transposition cipher is easily recognized because it has the same letter frequencies as the original plaintext.  
The transposition cipher can be made significantly more secure by performing more than one stage of transposition.

**What are the drawbacks of Steganography?**  
Steganography is the art of hiding information in plain sight, by embedding information inside another file using specific patterns. But it has some drawbacks:  
1. Only *small amount of data* can be hidden relative to the size of the cover, trying to hide to much data distorts the cover file making easier to detect
2. Vulnerable to specialized algorithms that can detect hidden data 
3. Operation performed on the cover file can easily destroy or alter the embedded message

### Programming Problems 
1. Write a program that can encrypt and decrypt using the general Caeser cipher
2. Write a program that can encrypt and decrypt using the affine cipher 
3. Write a program that can perform a letter frequency attack on an additive cipher without human intervention. Your software should produce possible plaintexts in rough order of likelihood, allowing the user to specify "give me the top 10 possible plaintexts"
4. Write a program that can perform a letter frequency attack on any monoalphabetic substitution cipher without human intervention. Your software should produce possible plaintexts in rough order of likelihood, allowing the user to specify "give me the top 10 possible plaintexts"
5. Create a software that can encrypt and decrypt using a 2x2 Hill cipher
6. Create a software that can encrypt perform a fast known plaintext attack on a Hill cipher, given the dimension m. How fast are your algorithms as a function of m?
